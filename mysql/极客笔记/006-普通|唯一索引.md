# 普通索引 和 唯一索引


# 查询过程
  select * from T where k=5

  1、普通索引，找到满足条件的记录，需要找下一个，知道不满足条件为止
  2、唯一索引，找到一个记录就停止索引；

  不同性能的差距几乎很小


# 更新过程

  插入|更新数据过程：
    1、数据在内存中：
      a、唯一索引：找到对应位置，判断有没有违背唯一性约束，再进行更新
      b、普通索引：找到对应位置，插入|更新值
      说明：差距不大，只是多一步判断

    2、数据不在内存中：
      a、唯一索引：读取数据进内存，判断唯一性约束，插入|更新
      b、普通索引：将插入|更新操作记录在 change buffer 中，完成操作
      说明：唯一多了读数据，磁盘 IO，对性能影响很大







# change buffer
  在更新数据时，分一下两种情况
    1、数据所在的数据页已经在内存中，则直接更新内存数据
    2、数据所在的数据页不在内存，将更新操作记录在 change buffer 中，当有查询这条数据时，把对应数据页读入内存，然后执行 change buffer 中的更新；

  说明：
    1、将 change buffer 中的数据保存到对应数据页的操作，叫做 merger。执行条件
      a、读取对应数据
      b、系统后台定期 merge
      c、数据库正常关闭的时候，shutdown 操作
      d、change buffer 内存不足

    2、 唯一索引在执行插入时，需要将数据读入内存，判断是否违反唯一性约束，所以，唯一索引在插入和更新时用不上 change buffer，
    3、change buffer 用的是 buffer pool 中的内存，不能无限大，由参数 innodb_change_buffer_max_size 控制，值为 50 表示占 buffer pool 的 50%

## 使用场景

  对于读多写少的业务，适合使用 change buffer，ex：账单类、日志类的系统
  如果更新之后，马上就有查询操作，这样，change buffer 反而拖累性能

