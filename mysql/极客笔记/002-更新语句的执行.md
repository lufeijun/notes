# SQL 执行过程



# redo log 的原理：innodb 引擎特有的功能


### WAL 技术，write-ahead-logging
  先写日志，在写磁盘。如果有一条更新记录，innodb 引擎就会先将记录写到 redo log 里边，并更新到内存，这个时候更新语句就算完成了，之后
在适当的时候，innodb 会将这个操作记录更新到磁盘中去。有了 redo log ，innodb 就具备了 crash-safe 了


### 基本实现
  mysql 中会有一片内存用来保存 redo log，里边有两个指针，write pos 和 check pos：
    a、write pos：当前记录的位置，一边写一遍向后移动，如到内存末尾，则移动到首位
    b、check pos：当前要擦除的位置，也是往后推移并且循环，该位置之后的内容表示还没有持久化到磁盘，擦除：把内容记录更新到数据库文件
  这两个指针之间的空间，表示 redo log 剩余的空间，如果 write 追上 check 了，innodb 就停止更新操作，调用系统资源进行擦除操作


### innodb 引擎更新数据步骤
  在 innodb 中，数据已数据页的形式保存在磁盘中，在读取数据时，也会以页为最小单元，读取数据到内存中，所以，在更新数据的时候，会分两种情况

    1、需要更新的数据已经在内存中，
    2、需要更新的数据没有在内存中，
  
  具体更新步骤：
    1、如果数据在内存中，直接更新内存
    2、如果不在内存，就在内存的 change buffer 区域，记录本次更新语句
    3、将上述两个记录保存到 redo log 日志中
  这样，就完成了整个更新操作。

  对应如果在执行查询语句时：
    1、如果数据在内存中，则直接返回结果
    2、如果不在，就需要提取对应数据所在的数据页，并且结合 change buffer 中的操作日志，生成一个正确的版本并且返回结果
  

### redo log 和 change buffer
  redo log：节省的是随机写磁盘的 IO 消耗，
  change buffer：节省的是随机读磁盘的 IO 消耗



# 日志模块 binlog ： mysql server 层的日志模块
  
 





# SQL 更新执行过程

 ex：update k=k+1 from T where id = 2

  1、执行器先找引擎找到 id = 2 的这行，
  2、执行器拿着返回的数据，把这个值 +1 ，得到新的一行数据，在调用接口写入这行新数据
  3、引擎将这行新数据写到内存中，同时将这个更新操作记录到 redo log中，此时 redo log 处于 prepare 状态，然后告知执行器执行完成了。随时可以提交事务
  4、执行器生成这个操作的 binlog ，并把 binlog 写到磁盘
  5、执行器调用引擎的事务提交接口，引擎把刚刚写入的 redo log 改成提交状态，更新完成
  
  以上操作分别在 执行器 和 引擎层 完成



### 两阶段提交
  目的：为了让 redo log 和 binlog 之间的逻辑保持一致
  












# 新概念

  1、redo log 大致原理
  2、binlog 原理
  3、内存数据页










