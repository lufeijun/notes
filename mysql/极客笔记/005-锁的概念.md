# 锁的作用
  
  处理并发问题，分为 全局锁、表级锁、行锁


# 全局锁
  对整个数据库实例进行加锁，flush tables with read lock ( FTWRL )，典型应用就是做全库逻辑备份

    
  mysql 提供 mysqldump 命令进行数据库备份，当使用 --single-transaction 时，导数据之前会产生一个事务，来确保数据一致性，且同时可以对外提供服务，但这个只使用与支持事务的数据库引擎


  set global readonly=true ， 也可以使整个库处于只读状态，但是会有以下风险
    1、有些系统会通过这个参数做其他逻辑判断，比如是否为从库
    2、使用 FTWRL 时，如果客户端异常，在断开之后，这个锁会被释放；如果使用 readonly 时，则整个数据库长时间处于不可写状态



# 表级锁
  
  表锁： lock tables tableName read/write
    可以使用 UNclock tables 主动释放，也可以在客户端断开时自动释放
    lock tables 除了限制别的线程的读写，也限制了本线程接下来的操作对象

  元数据锁( meta data lock , MDL )：
    不需要显示使用，在访问一个表的时候会被自动加上，其作用是：保证读写的正确性，当在查询遍历一个表时，会自动加上 MDL 读锁，此前其他线程不能修改该表的结构。

    在 mysql5.5 之后引入 mdl，当对表做增删改查的时候，加 MDL 读锁；当要对表结构做修改时，则加 MDL 写锁；读锁之间不互斥，读锁与写锁、写锁之间互斥。

    在事务中，MDL 锁会在语句执行的时候开始申请，但是并不会在语句执行完马上释放，而是会等到整个事务提交之后才会释放；



### 修改表字段时，需要防止出现锁等待导致系统挂掉的问题

  1、在数据库 information_schema 库的 innodb_trx 表中，可以查询当前执行中的事务，当事务比较少时，再执行更新表操作

  2、如果是热数据，一直有事务产生，则在修改是添加等待时间。超过这个时间之后，放弃对表的修改，稍后再试
     alter table tableName nowait add column ...
     alter table tableName wait n add column ...


# 行锁
  mysql 行锁是在引擎层由各个引擎自己实现的，innodb 支持，myisam 不支持；

  两阶段锁协议：在 innodb 事务中，行锁是在需要的时候才加上的，单并不是不需要就立即释放，而是要等到事务结束才会被释放，这就是两阶段锁协议。
  基于此，可以想象，如果在事务中需要锁多个行，要把最可能造成冲突、最可能影响并发度的锁尽量放到最后


### 死锁 死锁检测

  当并发系统出现循环资源依赖，ex: 事务1需要事务2释放一些资源，而事务2也正好在等事务1释放另一些资源，这样就造成死锁现象；


  策略：
    1、进入等待，直到超时，参数 innodb_lock_wait_timeout 来设置，默认为 50s
    2、死锁检测，innodb_deadlock_detect 设置为 on；












# sql 命令
  1、mysqldump 备份语句




